/// Tool registration and management module
/// This module organizes all tools into logical categories for easy discovery and management
pub mod computer_automation;
pub mod util;
pub mod web_search;

pub use computer_automation::AutomationHandler;
pub use util::is_delegation_request;

use crate::agents::ToolDefinition;
use anyhow::Result;
use computer_automation::get_all_automation_tools;
use util::get_all_utility_tools;
use web_search::get_all_web_tools;

/// Get all available tools in the system
///
/// Returns a unified list of all tools organized by category:
/// - Computer Automation: Mouse, keyboard, and system control
/// - Web Search: Web searching and URL fetching capabilities
/// - Utilities: Delegation and meta-tools
pub fn get_all_tools() -> Vec<ToolDefinition> {
    let mut tools = Vec::new();

    // Add computer automation tools
    tools.extend(get_all_automation_tools());

    // Add web tools
    tools.extend(get_all_web_tools());

    // Add utility tools
    tools.extend(get_all_utility_tools());

    tools
}

/// Get tools by category
#[allow(dead_code)]
pub fn get_tools_by_category(category: &str) -> Vec<ToolDefinition> {
    get_all_tools()
        .into_iter()
        .filter(|tool| tool.category == category)
        .collect()
}

/// Lookup a specific tool by ID
pub fn get_tool_by_id(tool_id: &str) -> Option<ToolDefinition> {
    get_all_tools().into_iter().find(|tool| tool.id == tool_id)
}

/// Execute a tool by name with the given arguments
///
/// This function routes tool execution to the appropriate module based on the tool name.
/// For computer automation tools, it requires an AutomationHandler instance to handle
/// the actual hardware interaction.
///
/// # Arguments
/// * `tool_name` - The ID of the tool to execute
/// * `arguments` - JSON arguments for the tool
/// * `handler` - Optional AutomationHandler for executing automation commands
///
/// # Returns
/// * `Ok(String)` - Tool execution result
/// * `Err(anyhow::Error)` - Execution error
pub fn execute_tool(
    tool_name: &str,
    arguments: &serde_json::Value,
    handler: Option<&AutomationHandler>,
) -> Result<String> {
    // Try to find tool first
    let tool =
        get_tool_by_id(tool_name).ok_or_else(|| anyhow::anyhow!("Unknown tool: {}", tool_name))?;
    
    // Route to appropriate module based on category
    match tool.category.as_str() {
        "mouse" | "keyboard" | "system" => {
            // Computer automation tools
            let handler = handler
                .ok_or_else(|| {
                    anyhow::anyhow!("AutomationHandler required for tool: {}", tool_name)
                })?;
            computer_automation::execute_automation_tool(tool_name, arguments, handler)
        }
        "web" => {
            // Web search/fetch tools - use blocking spawn for proper async handling
            tokio::task::block_in_place(|| {
                web_search::execute_web_search(tool_name, arguments)
            })
        }
        "delegation" => {
            // Utility/delegation tools
            util::execute_utility_tool(tool_name, arguments)
        }
        _ => Err(anyhow::anyhow!("Unknown tool category: {}", tool.category)),
    }
}
        "web" => {
            // Web search/fetch tools (async)
            web_search::execute_web_tool_async(tool_name, arguments).await
        }
        "delegation" => {
            // Utility/delegation tools
            util::execute_utility_tool(tool_name, arguments)
        }
        _ => Err(anyhow::anyhow!("Unknown tool category: {}", tool.category)),
    }
}

/// Backward compatibility: keep sync version for non-async callers
#[allow(dead_code)]
pub fn execute_tool(
    tool_name: &str,
    arguments: &serde_json::Value,
    handler: Option<&AutomationHandler>,
) -> Result<String> {
    let rt =
        tokio::runtime::Runtime::new().map_err(|_| anyhow::anyhow!("Failed to create runtime"))?;
    rt.block_on(execute_tool_async(tool_name, arguments, handler))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_all_tools_loaded() {
        let tools = get_all_tools();
        assert!(!tools.is_empty(), "No tools loaded");
    }

    #[test]
    fn test_tool_categories() {
        let tools = get_all_tools();
        let categories: Vec<String> = tools.iter().map(|t| t.category.clone()).collect();
        assert!(
            categories.contains(&"mouse".to_string()),
            "Missing mouse category"
        );
        assert!(
            categories.contains(&"keyboard".to_string()),
            "Missing keyboard category"
        );
        assert!(
            categories.contains(&"web".to_string()),
            "Missing web category"
        );
        assert!(
            categories.contains(&"delegation".to_string()),
            "Missing delegation category"
        );
    }

    #[test]
    fn test_get_tool_by_id() {
        let tool = get_tool_by_id("mouse_move");
        assert!(tool.is_some(), "mouse_move tool not found");

        let tool = get_tool_by_id("invalid_tool");
        assert!(tool.is_none(), "Invalid tool should not be found");
    }

    #[test]
    fn test_get_tools_by_category() {
        let mouse_tools = get_tools_by_category("mouse");
        assert!(!mouse_tools.is_empty(), "No mouse tools found");

        let web_tools = get_tools_by_category("web");
        assert!(!web_tools.is_empty(), "No web tools found");
    }
}
